#pragma kernel InitResult
#pragma kernel InitValues
#pragma kernel Paint
#pragma kernel AddValue
#pragma kernel ScaleAndOffsetValues

RWTexture2D<float4> Result;
RWTexture2D<float4> Values;

float4 BckgCol;
float2 ResultSize;
float ValueScale;
float ValueNew;
int ValuesSize;
int IndexNew;

#define EMPTY_COL float4(0, 0, 0, 0)

[numthreads(8,8,1)]
void InitResult (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = BckgCol;
}

[numthreads(8,1,1)]
void InitValues (uint3 id : SV_DispatchThreadID)
{
    Values[id.xy] = EMPTY_COL;
}

float ValueToUV(float x){
    float s = ResultSize.y - 1;
    float val = Values[float2(x, 0)].r + s / 2;
    return val;
}

[numthreads(8,8,1)]
void Paint (uint3 id : SV_DispatchThreadID)
{
    float val = ValueToUV(id.x);

    float prevVal = id.x < 1 ? val : ValueToUV(id.x - 1);
    float nextVal = id.x >= ResultSize.x - 1 ? val : ValueToUV(id.x + 1);

    float v1 = ( prevVal + val ) / 2;
    float v2 = ( nextVal + val ) / 2;

    //if (clamp(id.y, min(v1, v2), max(v1, v2)) == id.y){
    if (id.y < val)
    {
        Result[id.xy] = float4(1, 1, 1, 1);
        return;
	}

    Result[id.xy] = BckgCol;
}

[numthreads(8,1,1)]
void AddValue (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x == IndexNew){
        Values[id.xy] = float4(ValueNew, 0, 0, 0);
        return;
	}

    if (IndexNew >= ValuesSize){
        if ((int)id.x == ValuesSize - 1){
            Values[id.xy] = float4(ValueNew, 0, 0, 0);
            return;
	    }

        Values[id.xy] = Values[id.xy + float2(1, 0)];
        return;
    }

    if (id.x > IndexNew){
        Values[id.xy] = EMPTY_COL;
	}
}

[numthreads(8,1,1)]
void ScaleAndOffsetValues (uint3 id : SV_DispatchThreadID)
{
    float val = Values[id.xy].r;
    Values[id.xy] = float4( val * ValueScale, 0, 0, 1 );
}
