#pragma kernel InitResult
#pragma kernel InitValues
#pragma kernel Paint
#pragma kernel AddValue

RWTexture2D<float4> Result;
RWTexture2D<float4> Values;

float4 BckgCol;
float4 LinesCol;
float2 ResultSize;
float MaxOffset;
float ValueNew;
int ValuesSize;
int IndexNew;

#define EMPTY_COL float4(0, 0, 0, 0)

bool IsEmpty(float x){
    return Values[float2(x, 0)].r == EMPTY_COL.r;
}

[numthreads(8,8,1)]
void InitResult (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = BckgCol;
}

[numthreads(8,1,1)]
void InitValues (uint3 id : SV_DispatchThreadID)
{
    Values[id.xy] = EMPTY_COL;
}

float ValueToUV(float x){
    float c = (ResultSize.y - 1);
    float val = (clamp(Values[float2(x, 0)].r, -MaxOffset, MaxOffset) / MaxOffset + 1) / 2 * c;
    return val;
}

[numthreads(8,8,1)]
void Paint (uint3 id : SV_DispatchThreadID)
{
    if (IsEmpty(id.x)){
        return;
	}

    float val = ValueToUV(id.x);

    float prevVal = id.x < 1 ? val : ValueToUV(id.x - 1);
    float nextVal = id.x >= ResultSize.x - 1 ? val : ValueToUV(id.x + 1);

    float v1 = ( prevVal + val ) / 2;
    float v2 = ( nextVal + val ) / 2;

    if (clamp(id.y, min(v1, v2)-1, max(v1, v2)+1) == id.y){
        Result[id.xy] = LinesCol;
        return;
	}
    /*
    if (id.y < val)
    {
        Result[id.xy] = float4(1, 1, 1, 1);
        return;
	}
    */

    Result[id.xy] = BckgCol;
}

[numthreads(8,1,1)]
void AddValue (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x == IndexNew){
        Values[id.xy] = float4(ValueNew, 0, 0, 0);
        return;
	}

    if (IndexNew >= ValuesSize){
        if ((int)id.x == ValuesSize - 1){
            Values[id.xy] = float4(ValueNew, 0, 0, 0);
            return;
	    }

        Values[id.xy] = Values[id.xy + float2(1, 0)];
        return;
    }

    if (id.x > IndexNew){
        Values[id.xy] = EMPTY_COL;
	}
}
